import pandas
import multiprocessing
import sys

import openalea.plantgl.all as pgl
from openalea.lpy import Lsystem
from alinea.astk.sun_and_sky import sun_sky_sources, sky_sources
from alinea.caribu.CaribuScene import CaribuScene
from alinea.caribu.light import light_sources

# default location and dates (Montpellier)
_daydate = '2000-06-21'
_timezone = 'Europe/Paris'
_longitude = 3.52
_latitude = 43.36
_altitude = 56

# default parameters for lsystem
_lsys_params = {'SEED': 17, 'INSERTION_ANGLE' : 45 , 'PHYLLOTAXY': 144, 'BRANCH_ELASTICITY': 0.06,
                      'INTERNODE_FLENGTH':3.5, 'LONGGU_PEAK_POSITION': 0.5, 'TIMESTEP':2, 'LIGHTON': False,
                      'ORCHARD': False}


def illuminate(lscene, isolated=True, clear_sky=False, daydate=_daydate, longitude=_longitude, latitude=_latitude,
               altitude=_altitude, timezone=_timezone):
    """ Illuminate a plant
    Args:
        isolated : is the plant isolated or within a canopy ?
        clear_sky: use clear_sky (homogeneous sky is used otherwise)
        irradiance: (float) sum of horizontal irradiance of all sources. If None
         diffuse horizontal clear_sky irradiance are used for clear_sky type and
          20% attenuated clear_sky global horizontal irradiances are used for
          soc and uoc types.
        dates: A pandas datetime index (as generated by pandas.date_range). If
            None, hourly values for daydate are used.
        daydate: (str) yyyy-mm-dd (not used if dates is not None).
        longitude: (float) in degrees
        latitude: (float) in degrees
        altitude: (float) in meter
        timezone:(str) the time zone (not used if dates are already localised)

    Returns:
        elevation (degrees), azimuth (degrees, from North positive clockwise),
        and horizontal irradiance of sources
    """
    if not clear_sky:
        light = light_sources(*sky_sources())
    else:
        sun, sky = sun_sky_sources(daydate=daydate, longitude=longitude, latitude=latitude, altitude=altitude,
                                   timezone=timezone, normalisation=1)
        light = light_sources(*sun) + light_sources(*sky)
    inter_row = 300
    inter_plant = 150
    pattern = (-0.5 * inter_row, -0.5 * inter_plant,
               0.5 * inter_row, 0.5 * inter_plant)
    cs = CaribuScene(lscene, light=light, pattern=pattern, scene_unit='cm')
    raw, agg = cs.run(direct=True, simplify=True, infinite=not isolated)
    return cs, raw, agg


#scalars = [('SEED', 'Integer', 17, 0, 100), ('INSERTION_ANGLE', 'Integer', 45, 0, 90),
# ('PHYLLOTAXY', 'Integer', 144, 0, 359), ('BRANCH_ELASTICITY', 'Float', 0.06, 0.0, 0.1, 2),
# ('INTERNODE_FLENGTH', 'Float', 3.5, 0.0, 5.0, 1), ('LONGGU_PEAK_POSITION', 'Float', 0.5, 0.0, 0.9, 1),
# ('TIMESTEP', 'Integer', 1, 1, 100), ('LIGHTON', 'Bool', False), ('ORCHARD', 'Bool', False)]

def run_lsys(**kwds):
    params={k:v for k,v in _lsys_params.iteritems()}
    params.update(kwds)
    l = Lsystem('sensitivityanalysis.lpy', params)
    lstring = l.iterate()
    lscene = l.sceneInterpretation(lstring)
    return lstring, lscene


def load_res(output='res_isolated625simus.csv'):
    return pandas.read_csv(output, index_col=0)

def display_res(df, irow=0, light=False):
    row = df.iloc[irow,]
    parname = _lsys_params.keys()
    output = ['Fruit_Ei', 'Fruit_area', 'Leaf_Ei', 'Leaf_area', 'Internode_Ei', 'Internode_area']
    lstring, lscene = run_lsys(**row[row.index[row.index.isin(parname)]].to_dict())
    if not light:
        pgl.Viewer.display(lscene)
    else:
        kwds = row[row.index[~row.index.isin(parname + output)]].to_dict()
        cs, raw, agg = illuminate(lscene, **kwds)
        cs.plot(raw['Ei'], minval=0, maxval=1)


def plant_irradiance(lstring, lscene, isolated=True, clear_sky=False, illuminated=None):
    if illuminated is None:
        _, _, agg = illuminate(lscene, isolated=isolated, clear_sky=clear_sky)
    else:
        _, _, agg = illuminated
    labels = {i: mod.name for i,mod in enumerate(lstring) if i in agg['Ei']}
    agg.update({'label': labels})
    df = pandas.DataFrame(agg)
    res={}
    for lab in set(df.label):
        dfl = df.loc[df.label==lab,:]
        area = dfl.area.sum()
        ei = sum(dfl.Ei * dfl.area) / area
        res[lab + '_area'] = area
        res[lab + '_Ei'] = ei
    return res

def run_sim(row, **kwds):
    lstring, lscene = run_lsys(**row.to_dict())
    res = plant_irradiance(lstring, lscene, **kwds)
    for k in res:
        row[k] = res[k]
    for arg in kwds:
        row[arg] = kwds[arg]
    return row

def run_sim_xrun(xargs):
    row, kwds = xargs
    return run_sim(row, **kwds)



# ==============================================================================
# ==============================================================================

def process(path_input=None, path_output=None, nb_process=1,
            start=None, end=None, df_input=None, **kwds):

    if df_input is None:
        if path_input is not None:
            df_input = pandas.read_csv(path_input)
        else:
            df_input = pandas.DataFrame({'INSERTION_ANGLE' : [45,60] , 'BRANCH_ELASTICITY': [0.04, 0.06]})

    rows = [row for index, row in df_input.iterrows()]

    if start is None:
        start = 0
    if end is None:
        end = len(rows)
    rows = rows[start:end]

    df_output = pool_function(rows, nb_process=nb_process, **kwds)

    if path_output is not None:
        df_output.to_csv(path_output)

    return df_output


def pool_function(rows, nb_process=2, verbose=True, **kwds):

    if nb_process <= 1:
        function = run_sim
        return run_function(function, rows, verbose=verbose, **kwds)

    function = run_sim_xrun
    pool = multiprocessing.Pool(nb_process)

    nb_rows = len(rows)
    df = pandas.DataFrame()
    args = [(row, kwds) for row in rows]
    for i, row in enumerate(pool.imap(function, args)):

        if verbose:
            print("%s : %d / %d" % (function.__name__, i, nb_rows))
            sys.stdout.flush()

        if row is not None:
            df = df.append(row)

    pool.close()
    pool.join()

    if verbose:
        print("%s : %d / %d" % (function.__name__, nb_rows, nb_rows))
        sys.stdout.flush()

    return df


def run_function(function, rows, verbose=True, **kwds):
    nb_rows = len(rows)
    df = pandas.DataFrame()
    for i, row in enumerate(rows):

        if verbose:
            print("%s : %d / %d" % (function.__name__, i, nb_rows))
            sys.stdout.flush()

        row = function(row, **kwds)
        if row is not None:
            df = df.append(row)

    if verbose:
        print("%s : %d / %d" % (function.__name__, nb_rows, nb_rows))
        sys.stdout.flush()

    return df


# ==============================================================================
# ==============================================================================

if __name__ == '__main__':
    # exp='ZA16'
    if len(sys.argv) > 1:
        # modulor config
        _, input, output, isolated, clear, nbproc = sys.argv
        nbproc = int(nbproc)
        process(path_input=input, path_output=output, nb_process=nbproc, isolated=eval(isolated), clear_sky=eval(clear))
